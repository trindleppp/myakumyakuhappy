<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Metaball (Wandering Mode)</title>
  <style>
    html,body { margin:0; height:100%; background:#111; }
    #app { position:fixed; inset:0; display:grid; place-items:center; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.4/dist/tweakpane.min.js";

  // ===== 設定 =====
  const INTERNAL_W = 1200, INTERNAL_H = 1200;
  const INIT_RANGE = 100, INIT_INTERVAL = 1.0, INIT_EYE_SCALE = 1.2;
  const INIT_ATTRACT = 60, INIT_REPEL = 100;
  const INIT_MOVE_SPEED = 100.0;

  const TAU = Math.PI * 2;
  const rand = (a,b)=> a + Math.random()*(b-a);

  // ===== シェーダ（省略、前回と同じ WebGL1版）=====
  const VERT = `
    precision highp float;
    attribute vec3 position;
    varying vec2 vUv;
    void main() {
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `;
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 centers[32];
    uniform float radii[32];
    uniform int num_circles;
    uniform vec3 blob_color;

    uniform vec2 eye_center;
    uniform float eye_radius;
    uniform vec2 pupil_center;
    uniform float pupil_radius;
    uniform vec3 eye_color;
    uniform vec3 pupil_color;

    uniform vec2 resolution;

    void main(){
        vec2 uv = vUv * resolution;
        float field = 0.0;
        for(int i=0;i<32;i++){
            if(i >= num_circles) break;
            vec2 d = uv - centers[i];
            float d2 = dot(d,d) + 1.0;
            float r = radii[i];
            field += (r*r) / d2;
        }
        if(field <= 0.8){ discard; }
        if(length(uv - pupil_center) < pupil_radius){
            gl_FragColor = vec4(pupil_color, 1.0); return;
        }
        if(length(uv - eye_center) < eye_radius){
            gl_FragColor = vec4(eye_color, 1.0); return;
        }
        gl_FragColor = vec4(blob_color, 1.0);
    }
  `;

  // ===== Blob =====
  class Blob {
    constructor(n=14, color=new THREE.Vector3(1,0,0), pos=new THREE.Vector2(INTERNAL_W/2, INTERNAL_H/2)){
      this.num_circles = n;
      this.color = color;
      this.pupil_color = new THREE.Vector3(1-color.x, 1-color.y, 1-color.z);

      this.centers = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.radii   = new Float32Array(32);
      this.base_r  = new Float32Array(32);
      this.phase   = new Float32Array(32);
      this.speed   = new Float32Array(32);
      this.targets = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.timer   = new Float32Array(32);

      for(let i=0;i<n;i++){
        this.base_r[i] = rand(10,30);
        this.radii[i]  = this.base_r[i];
        this.phase[i]  = rand(0,TAU);
        this.speed[i]  = rand(0.8,1.5);
        this.targets[i] = new THREE.Vector2(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
        this.timer[i] = rand(1,4);
      }
      this.base_avg_r = Array.from(this.base_r.slice(0,n)).reduce((a,b)=>a+b,0)/n;

      this.eye_pos = pos.clone();
      this.eye_target = this.eye_pos.clone();
      this.eye_timer = rand(0.5, INIT_INTERVAL);
      this.pupil_pos = pos.clone();
      this.pupil_target = pos.clone();
      this.pupil_timer = rand(1,3);

      this.eye_range = INIT_RANGE;
      this.eye_scale = INIT_EYE_SCALE;
      this.move_speed = INIT_MOVE_SPEED;
    }

    estimate_radius(){
      let cx=0, cy=0;
      for(let i=0;i<this.num_circles;i++){ cx+=this.centers[i].x; cy+=this.centers[i].y; }
      cx/=this.num_circles; cy/=this.num_circles;
      const center = new THREE.Vector2(cx,cy);
      let r=0;
      for(let i=0;i<this.num_circles;i++){
        const v=this.centers[i].clone().sub(center);
        r=Math.max(r,v.length()+this.radii[i]);
      }
      return { r, center };
    }

    apply_force(f){
      this.eye_pos.add(f);
      for(let i=0;i<this.num_circles;i++) this.centers[i].add(f);
    }

    update(dt){
      for(let i=0;i<this.num_circles;i++){
        this.phase[i]+=this.speed[i]*dt;
        this.radii[i]=Math.max(2,this.base_r[i]+20*Math.sin(this.phase[i]));
        this.timer[i]-=dt;
        if(this.timer[i]<=0){
          // === 画面全域をターゲットにする ===
          this.targets[i].set(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
          this.timer[i]=rand(2,5);
        }
        const dx=this.targets[i].x-this.centers[i].x;
        const dy=this.targets[i].y-this.centers[i].y;
        const d=Math.hypot(dx,dy);
        if(d>1e-3){
          const step=Math.min(this.move_speed*dt,d);
          this.centers[i].x+=dx/d*step;
          this.centers[i].y+=dy/d*step;
        }
      }

      const {r:r_est, center} = this.estimate_radius();
      const eye_r=this.base_avg_r*this.eye_scale;
      const pupil_r=eye_r*0.5;

      this.eye_timer-=dt;
      if(this.eye_timer<=0){
        const allow=Math.min(r_est, this.eye_range);
        const ang=rand(0,TAU), rad=rand(0,allow);
        this.eye_target.copy(center).add(new THREE.Vector2(Math.cos(ang)*rad, Math.sin(ang)*rad));
        this.eye_timer=INIT_INTERVAL;
      }
      this.eye_pos.add(this.eye_target.clone().sub(this.eye_pos).multiplyScalar(0.08));

      this.pupil_timer-=dt;
      if(this.pupil_timer<=0){
        const j=Math.max(3.0,eye_r*0.25);
        this.pupil_target=this.eye_pos.clone().add(new THREE.Vector2(rand(-j,j),rand(-j,j)));
        this.pupil_timer=rand(1,3);
      }
      this.pupil_pos.add(this.pupil_target.clone().sub(this.pupil_pos).multiplyScalar(0.05));

      const v=this.pupil_pos.clone().sub(this.eye_pos);
      if(v.length()>(eye_r-pupil_r)){
        v.setLength(Math.max(eye_r-pupil_r,0));
        this.pupil_pos.copy(this.eye_pos).add(v);
      }
    }

    uniforms(){
      const eye_r=this.base_avg_r*this.eye_scale;
      const pupil_r=eye_r*0.5;
      return {
        num_circles:this.num_circles,
        centers:this.centers,
        radii:Array.from(this.radii),
        blob_color:this.color,
        eye_center:this.eye_pos.clone(),
        eye_radius:eye_r,
        eye_color:new THREE.Vector3(1,1,1),
        pupil_center:this.pupil_pos.clone(),
        pupil_radius:pupil_r,
        pupil_color:this.pupil_color
      };
    }
  }

  // ===== Renderer周り（BlobRenderer, applyForces）は前回と同じ =====
  // 省略するけど差し替え不要、そのまま動く。

  // （ここに前回の BlobRenderer クラスと applyForces 関数を入れる）

  // ===== Three.js 初期化・ループも同じ =====
  // （前回の tick() のままでOK）
  </script>
</body>
</html>
