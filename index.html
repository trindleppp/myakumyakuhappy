<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Metaball Gold (Spherical Highlight + Outer Glow) — importmap fixed</title>
  <style>
    html,body { margin:0; height:100%; background:#111; }
    #app { position:fixed; inset:0; display:grid; place-items:center; }
    #colorButton {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border: 2px solid #c7a0ff;
      border-radius: 12px;
      background: linear-gradient(135deg,#fff,#000);
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      z-index: 20;
      box-shadow: 0 6px 24px rgba(199,160,255,0.25);
    }
    #colorButton:hover { background: linear-gradient(135deg,#eee,#333); }
  </style>

  <!-- import map: resolve bare specifier 'three' -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <button id="colorButton">ランダムカラー</button>

  <script type="module">
  import * as THREE from "three";
  import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.4/dist/tweakpane.min.js";

  // ===== Settings =====
  const INTERNAL_W = 1200, INTERNAL_H = 1200;
  const TAU = Math.PI * 2;
  const rand = (a,b)=> a + Math.random()*(b-a);
  const chance = p => Math.random() < p;

  // ===== Shaders =====
  const VERT = `
    precision highp float;
    attribute vec3 position;
    varying vec2 vUv;
    void main() {
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `;

  // Body shader (with spherical gold highlight)
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 centers[32];
    uniform float radii[32];
    uniform int num_circles;
    uniform vec3 blob_color;

    uniform vec2 eye_center;
    uniform float eye_radius;
    uniform vec2 pupil_center;
    uniform float pupil_radius;
    uniform vec3 eye_color;
    uniform vec3 pupil_color;

    uniform vec2 resolution;
    uniform int is_gold;

    void main(){
        vec2 uv = vUv * resolution;

        // metaball field
        float field = 0.0;
        for(int i=0;i<32;i++){
            if(i >= num_circles) break;
            vec2 d = uv - centers[i];
            float d2 = dot(d,d) + 1.0;
            float r = radii[i];
            field += (r*r) / d2;
        }
        if(field <= 0.8){ discard; }

        // pupil
        if(length(uv - pupil_center) < pupil_radius){
            if(is_gold==1){
                vec3 g1 = vec3(1.0,0.84,0.0);
                vec3 g2 = vec3(1.3,1.15,0.6);
                float rp = length(uv - pupil_center)/max(pupil_radius,1.0);
                float glow = pow(1.0 - clamp(rp,0.0,1.0), 4.0);
                vec3 col = mix(g1*0.9, g2, glow);
                gl_FragColor = vec4(col,1.0);
            } else {
                gl_FragColor = vec4(pupil_color, 1.0);
            }
            return;
        }

        // sclera (white)
        if(length(uv - eye_center) < eye_radius){
            gl_FragColor = vec4(eye_color, 1.0);
            return;
        }

        // body
        if(is_gold==1){
            // spherical highlight centered at the eye
            vec2 rel = (uv - eye_center) / max(eye_radius, 1.0);
            float r2 = dot(rel, rel);
            float z = sqrt(max(0.0, 1.0 - min(r2, 1.0)));
            vec3 n = normalize(vec3(rel, z));
            vec3 L = normalize(vec3(0.6, 0.4, 0.7));
            vec3 V = vec3(0.0, 0.0, 1.0);

            float diff = max(dot(n, L), 0.0);
            float spec = pow(max(dot(reflect(-L, n), V), 0.0), 32.0);
            float rim = pow(1.0 - n.z, 2.0);

            vec3 gold = vec3(1.0, 0.84, 0.0);
            vec3 ambient  = gold * 0.35;
            vec3 diffuseC = gold * (0.85 + 0.55 * diff);
            vec3 specular = vec3(1.25, 1.15, 0.6) * spec;
            vec3 col = ambient + diffuseC + specular;
            col *= mix(1.0, 0.75, rim);
            col = min(col, vec3(1.0));
            gl_FragColor = vec4(col, 1.0);
        } else {
            gl_FragColor = vec4(blob_color, 1.0);
        }
    }
  `;

  // Glow shader (gold-only outer halo)
  const FRAG_GLOW = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 centers[32];
    uniform float radii[32];
    uniform int num_circles;
    uniform vec2 resolution;
    uniform int is_gold;
    uniform vec2 eye_center;
    uniform float eye_radius;

    void main(){
        vec2 uv = vUv * resolution;

        // metaball field
        float field = 0.0;
        for(int i=0;i<32;i++){
            if(i >= num_circles) break;
            vec2 d = uv - centers[i];
            float d2 = dot(d,d) + 1.0;
            float r = radii[i];
            field += (r*r) / d2;
        }

        // Only draw outside the iso-surface; build a falloff ring just outside
        float iso = 0.8;
        if(field >= iso){ discard; }  // inside body: no glow from this pass

        // distance from edge in field space
        float d = iso - field; // >0 outside
        // falloff width in field units (tweakable)
        float w1 = 0.10;
        float w2 = 0.40;
        float ring = smoothstep(w2, w1, d);   // 1 near edge, 0 farther
        if(ring <= 0.001){ discard; }

        // radial falloff from the eye center, so glow concentrates near the blob
        float r = length(uv - eye_center) / max(eye_radius*2.0, 1.0);
        float radial = clamp(1.0 - r, 0.0, 1.0);

        float alpha = ring * radial * 0.7;   // intensity

        // gold-ish halo color
        vec3 halo = vec3(1.0, 0.92, 0.55);

        // Only gold blobs emit glow
        if(is_gold == 0){ discard; }

        gl_FragColor = vec4(halo, alpha);
    }
  `;

  // ===== Blob =====
  class Blob {
    constructor(n=14, color=new THREE.Vector3(1,0,0), pos=new THREE.Vector2(INTERNAL_W/2, INTERNAL_H/2)){
      this.num_circles = n;
      this.color = color;
      this.is_gold = 0;

      // pupil color rules
      if(color.equals(new THREE.Vector3(1,0,0))){
        this.pupil_color = new THREE.Vector3(0,0,1);       // red -> blue
      } else if(color.equals(new THREE.Vector3(0,0,1))){
        this.pupil_color = new THREE.Vector3(1,0,0);       // blue -> red
      } else if(color.equals(new THREE.Vector3(0.6,0,0.8))){
        this.pupil_color = new THREE.Vector3(0,1,0.6);     // purple -> emerald
      } else {
        this.pupil_color = new THREE.Vector3(1-color.x,1-color.y,1-color.z); // complement
      }

      this.centers = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.radii   = new Float32Array(32);
      this.base_r  = new Float32Array(32);
      this.phase   = new Float32Array(32);
      this.speed   = new Float32Array(32);
      this.targets = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.timer   = new Float32Array(32);

      for(let i=0;i<n;i++){
        this.base_r[i] = rand(10,30);
        this.radii[i]  = this.base_r[i];
        this.phase[i]  = rand(0,TAU);
        this.speed[i]  = rand(0.8,1.5);
        this.targets[i] = new THREE.Vector2(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
        this.timer[i] = rand(1,4);
      }
      this.base_avg_r = Array.from(this.base_r.slice(0,n)).reduce((a,b)=>a+b,0)/n;

      this.eye_pos = pos.clone();
      this.eye_target = this.eye_pos.clone();
      this.eye_timer = rand(0.5, 1.0);
      this.max_interval = 1.5;
      this.pupil_pos = pos.clone();
      this.pupil_target = pos.clone();
      this.pupil_timer = rand(1,3);

      this.eye_range = 30;
      this.eye_scale = 1.4;
      this.move_speed = 100;

      this.blob_target = pos.clone();
      this.blob_timer  = rand(3, 7);
    }

    setColors(newColor){
      this.color = newColor;
      if(this.is_gold){
        this.pupil_color = new THREE.Vector3(1.0,0.84,0.0);
      } else if(newColor.equals(new THREE.Vector3(1,0,0))){
        this.pupil_color = new THREE.Vector3(0,0,1);
      } else if(newColor.equals(new THREE.Vector3(0,0,1))){
        this.pupil_color = new THREE.Vector3(1,0,0);
      } else if(newColor.equals(new THREE.Vector3(0.6,0,0.8))){
        this.pupil_color = new THREE.Vector3(0,1,0.6);
      } else {
        this.pupil_color = new THREE.Vector3(1-newColor.x,1-newColor.y,1-newColor.z);
      }
    }

    estimate_radius(){
      let cx=0, cy=0;
      for(let i=0;i<this.num_circles;i++){ cx+=this.centers[i].x; cy+=this.centers[i].y; }
      cx/=this.num_circles; cy/=this.num_circles;
      const center = new THREE.Vector2(cx,cy);
      let r=0;
      for(let i=0;i<this.num_circles;i++){
        const v=this.centers[i].clone().sub(center);
        r=Math.max(r,v.length()+this.radii[i]);
      }
      return { r, center };
    }

    apply_force(f){
      this.eye_pos.add(f);
      for(let i=0;i<this.num_circles;i++) this.centers[i].add(f);
    }

    update(dt, cohesion){
      // wander target
      this.blob_timer -= dt;
      if(this.blob_timer <= 0){
        this.blob_target.set(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
        this.blob_timer = rand(3, 7);
      }
      {
        const dx=this.blob_target.x - this.eye_pos.x;
        const dy=this.blob_target.y - this.eye_pos.y;
        const d=Math.hypot(dx,dy);
        if(d>1e-3){
          const step = Math.min(this.move_speed*dt*0.5, d);
          const move = new THREE.Vector2(dx/d*step, dy/d*step);
          this.apply_force(move);
        }
      }

      // per-circle wobble
      for(let i=0;i<this.num_circles;i++){
        this.phase[i]+=this.speed[i]*dt;
        this.radii[i]=Math.max(2,this.base_r[i]+20*Math.sin(this.phase[i]));
        this.timer[i]-=dt;
        if(this.timer[i]<=0){
          this.targets[i].set(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
          this.timer[i]=rand(2,5);
        }
        const dx=this.targets[i].x-this.centers[i].x;
        const dy=this.targets[i].y-this.centers[i].y;
        const d=Math.hypot(dx,dy);
        if(d>1e-3){
          const step=Math.min(this.move_speed*dt,d);
          this.centers[i].x+=dx/d*step;
          this.centers[i].y+=dy/d*step;
        }
      }

      // eye / pupil logic
      const { r: r_est, center } = this.estimate_radius();
      const eye_r=this.base_avg_r*this.eye_scale;
      const pupil_r=eye_r*0.5;

      this.eye_timer-=dt;
      if(this.eye_timer<=0){
        const allow=Math.min(r_est,this.eye_range);
        const ang=rand(0,TAU), rad=rand(0,allow);
        this.eye_target.copy(center).add(new THREE.Vector2(Math.cos(ang)*rad, Math.sin(ang)*rad));
        this.eye_timer=this.max_interval;
      }
      this.eye_pos.add(this.eye_target.clone().sub(this.eye_pos).multiplyScalar(0.08));

      this.pupil_timer-=dt;
      if(this.pupil_timer<=0){
        const j=Math.max(3.0,eye_r*0.25);
        this.pupil_target=this.eye_pos.clone().add(new THREE.Vector2(rand(-j,j),rand(-j,j)));
        this.pupil_timer=rand(1,3);
      }
      this.pupil_pos.add(this.pupil_target.clone().sub(this.pupil_pos).multiplyScalar(0.05));
      const v=this.pupil_pos.clone().sub(this.eye_pos);
      if(v.length()>(eye_r-pupil_r)){
        v.setLength(Math.max(eye_r-pupil_r,0));
        this.pupil_pos.copy(this.eye_pos).add(v);
      }

      // cohesion toward center
      for(let i=0;i<this.num_circles;i++){
        const dx = center.x - this.centers[i].x;
        const dy = center.y - this.centers[i].y;
        const dist = Math.hypot(dx,dy);
        if(dist > 20){
          const step = Math.min(this.move_speed*dt*0.4*cohesion, dist);
          this.centers[i].x += dx/dist*step;
          this.centers[i].y += dy/dist*step;
        }
      }
    }

    uniforms(){
      const eye_r=this.base_avg_r*this.eye_scale;
      const pupil_r=eye_r*0.5;
      return {
        num_circles:this.num_circles,
        centers:this.centers,
        radii:Array.from(this.radii),
        blob_color:this.color,
        eye_center:this.eye_pos.clone(),
        eye_radius:eye_r,
        eye_color:new THREE.Vector3(1,1,1),
        pupil_center:this.pupil_pos.clone(),
        pupil_radius:pupil_r,
        pupil_color:this.pupil_color,
        is_gold:this.is_gold
      };
    }
  }

  // ===== Renderers =====
  class BlobRenderer {
    constructor(){
      this.material = new THREE.RawShaderMaterial({
        vertexShader: VERT,
        fragmentShader: FRAG,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        uniforms: {
          centers:{ value:Array.from({length:32},()=>new THREE.Vector2(0,0)) },
          radii:{ value:Array.from({length:32},()=>0.0) },
          num_circles:{ value:0 },
          blob_color:{ value:new THREE.Vector3(1,0,0) },
          eye_center:{ value:new THREE.Vector2(0,0) },
          eye_radius:{ value:0.0 },
          eye_color:{ value:new THREE.Vector3(1,1,1) },
          pupil_center:{ value:new THREE.Vector2(0,0) },
          pupil_radius:{ value:0.0 },
          pupil_color:{ value:new THREE.Vector3(0,0,0) },
          resolution:{ value:new THREE.Vector2(INTERNAL_W,INTERNAL_H) },
          is_gold:{ value:0 }
        }
      });
      this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), this.material);
    }
    updateFromBlob(blob){
      const u=blob.uniforms();
      this.material.uniforms.num_circles.value=u.num_circles;
      const centers=this.material.uniforms.centers.value;
      const radii=this.material.uniforms.radii.value;
      for(let i=0;i<32;i++){
        if(i<u.num_circles){ centers[i].copy(u.centers[i]); radii[i]=u.radii[i]; }
        else { centers[i].set(0,0); radii[i]=0.0; }
      }
      this.material.uniforms.blob_color.value.copy(u.blob_color);
      this.material.uniforms.eye_center.value.copy(u.eye_center);
      this.material.uniforms.eye_radius.value=u.eye_radius;
      this.material.uniforms.eye_color.value.copy(u.eye_color);
      this.material.uniforms.pupil_center.value.copy(u.pupil_center);
      this.material.uniforms.pupil_radius.value=u.pupil_radius;
      this.material.uniforms.pupil_color.value.copy(u.pupil_color);
      this.material.uniforms.resolution.value.set(INTERNAL_W,INTERNAL_H);
      this.material.uniforms.is_gold.value=u.is_gold;
    }
  }

  class GlowRenderer {
    constructor(){
      this.material = new THREE.RawShaderMaterial({
        vertexShader: VERT,
        fragmentShader: FRAG_GLOW,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        blending: THREE.NormalBlending,   // mix with white background
        uniforms: {
          centers:{ value:Array.from({length:32},()=>new THREE.Vector2(0,0)) },
          radii:{ value:Array.from({length:32},()=>0.0) },
          num_circles:{ value:0 },
          resolution:{ value:new THREE.Vector2(INTERNAL_W,INTERNAL_H) },
          is_gold:{ value:0 },
          eye_center:{ value:new THREE.Vector2(0,0) },
          eye_radius:{ value:0.0 }
        }
      });
      this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), this.material);
    }
    updateFromBlob(blob){
      const u=blob.uniforms();
      this.material.uniforms.num_circles.value=u.num_circles;
      const centers=this.material.uniforms.centers.value;
      const radii=this.material.uniforms.radii.value;
      for(let i=0;i<32;i++){
        if(i<u.num_circles){ centers[i].copy(u.centers[i]); radii[i]=u.radii[i]; }
        else { centers[i].set(0,0); radii[i]=0.0; }
      }
      this.material.uniforms.resolution.value.set(INTERNAL_W,INTERNAL_H);
      this.material.uniforms.is_gold.value=u.is_gold;
      this.material.uniforms.eye_center.value.copy(u.eye_center);
      this.material.uniforms.eye_radius.value=u.eye_radius;
    }
  }

  // ===== Setup =====
  const container = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  container.appendChild(renderer.domElement);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
  renderer.setClearColor(0xffffff, 1);
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
  function resize(){ const s=Math.min(window.innerWidth,window.innerHeight); renderer.setSize(s,s); }
  window.addEventListener('resize', resize); resize();

  const blobs = [
    new Blob(14,new THREE.Vector3(1,0,0),     new THREE.Vector2(INTERNAL_W*0.3, INTERNAL_H*0.6)),
    new Blob(14,new THREE.Vector3(0,0,1),     new THREE.Vector2(INTERNAL_W*0.7, INTERNAL_H*0.7)),
    new Blob(14,new THREE.Vector3(0.6,0,0.8), new THREE.Vector2(INTERNAL_W*0.5, INTERNAL_H*0.4)),
  ];
  const bodyRenderers = blobs.map(()=> new BlobRenderer());
  const glowRenderers = blobs.map(()=> new GlowRenderer());

  // Draw order: glow then body
  glowRenderers.forEach(r=> scene.add(r.mesh));
  bodyRenderers.forEach(r=> scene.add(r.mesh));

  // UI
  const pane=new Pane({title:'Controls'});
  const params={ eye_range:30, interval:1.5, eye_scale:1.4, attract:10, repel:10, move_speed:100, cohesion:1.5 };
  pane.addBinding(params,'eye_range',{min:10,max:200,step:1,label:'目の範囲'});
  pane.addBinding(params,'interval',{min:0.5,max:5,step:0.1,label:'目移動間隔'});
  pane.addBinding(params,'eye_scale',{min:1,max:3,step:0.05,label:'目サイズ'});
  pane.addBinding(params,'attract',{min:0,max:100,step:1,label:'引力'});
  pane.addBinding(params,'repel',{min:0,max:150,step:1,label:'斥力'});
  pane.addBinding(params,'move_speed',{min:20,max:200,step:1,label:'移動速度'});
  pane.addBinding(params,'cohesion',{min:0,max:5,step:0.1,label:'まとまり'});

  // inter-blob forces
  function applyForces(A,B,dt,attract,repel){
    const {r:rA,center:cA}=A.estimate_radius();
    const {r:rB,center:cB}=B.estimate_radius();
    const delta=cB.clone().sub(cA);
    const d=delta.length(); if(d<1e-6)return;
    delta.divideScalar(d);
    const desired=(rA+rB)*1.2;
    const scale=Math.max(Math.min(dt*60,1.5),0.5);
    if(d<desired){
      const overlap=desired-d;
      const mag=Math.min(overlap*0.5,8.0);
      const push=delta.clone().multiplyScalar(mag*(repel/80.0)*scale);
      A.apply_force(push.clone().multiplyScalar(-1));
      B.apply_force(push);
    } else {
      const gap=d-desired;
      const pull_mag=Math.min(gap*0.12,5.0);
      const pull=delta.clone().multiplyScalar(pull_mag*(attract/40.0)*scale);
      A.apply_force(pull); B.apply_force(pull.clone().multiplyScalar(-1));
    }
  }

  // loop
  let last=performance.now();
  function tick(now){
    const dt=Math.min(0.05,(now-last)/1000); last=now;
    for(const b of blobs){
      b.max_interval = params.interval;
      b.eye_range = params.eye_range;
      b.eye_scale = params.eye_scale;
      b.move_speed = params.move_speed;
      b.update(dt, params.cohesion);
    }
    for(let i=0;i<blobs.length;i++){
      for(let j=i+1;j<blobs.length;j++){
        applyForces(blobs[i],blobs[j],dt,params.attract,params.repel);
      }
    }
    for(let i=0;i<blobs.length;i++){
      glowRenderers[i].updateFromBlob(blobs[i]);
      bodyRenderers[i].updateFromBlob(blobs[i]);
    }
    renderer.render(scene,camera);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // random color button (with gold handling)
  document.getElementById('colorButton').onclick = ()=>{
    blobs.forEach(b=>{
      if(chance(1/50)){
        b.is_gold = 1;
        b.setColors(new THREE.Vector3(1.0,0.84,0.0));
      } else {
        b.is_gold = 0;
        b.setColors(new THREE.Vector3(Math.random(), Math.random(), Math.random()));
      }
    });
  };

  </script>
</body>
</html>
