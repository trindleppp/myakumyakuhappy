<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Metaball (Gold Special)</title>
  <style>
    html,body { margin:0; height:100%; background:#111; }
    #app { position:fixed; inset:0; display:grid; place-items:center; }
    #colorButton {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: black;
      color: white;
      border: 2px solid #d8b4fe;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }
    #colorButton:hover {
      background: #222;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <button id="colorButton">ランダムカラー</button>

  <script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.4/dist/tweakpane.min.js";

  // ===== 設定 =====
  const INTERNAL_W = 1200, INTERNAL_H = 1200;
  const TAU = Math.PI * 2;
  const rand = (a,b)=> a + Math.random()*(b-a);

  // ===== シェーダ =====
  const VERT = `
    precision highp float;
    attribute vec3 position;
    varying vec2 vUv;
    void main() {
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `;
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 centers[32];
    uniform float radii[32];
    uniform int num_circles;
    uniform vec3 blob_color;

    uniform vec2 eye_center;
    uniform float eye_radius;
    uniform vec2 pupil_center;
    uniform float pupil_radius;
    uniform vec3 eye_color;
    uniform vec3 pupil_color;

    uniform vec2 resolution;

    void main(){
        vec2 uv = vUv * resolution;
        float field = 0.0;
        for(int i=0;i<32;i++){
            if(i >= num_circles) break;
            vec2 d = uv - centers[i];
            float d2 = dot(d,d) + 1.0;
            float r = radii[i];
            field += (r*r) / d2;
        }
        if(field <= 0.8){ discard; }

        // pupil が金ピカの場合 → 特別処理
        vec3 goldBase = vec3(1.0, 0.84, 0.0);
        vec3 goldPupil = vec3(1.0, 0.9, 0.3);

        if(length(uv - pupil_center) < pupil_radius){
            if(distance(pupil_color, goldPupil) < 0.05){
                vec2 lightDir = normalize(vec2(-0.7, 0.7));
                vec2 normal = normalize(uv - pupil_center);
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 highlight = vec3(1.0, 0.95, 0.6);
                vec3 shiny = mix(goldPupil, highlight, pow(diff, 5.0));
                gl_FragColor = vec4(shiny, 1.0); return;
            } else {
                gl_FragColor = vec4(pupil_color, 1.0); return;
            }
        }
        if(length(uv - eye_center) < eye_radius){
            gl_FragColor = vec4(eye_color, 1.0); return;
        }
        if(distance(blob_color, goldBase) < 0.05){
            vec2 lightDir = normalize(vec2(-0.7, 0.7));
            vec2 normal = normalize(uv - eye_center);
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 highlight = vec3(1.0, 0.95, 0.6);
            vec3 shinyGold = mix(goldBase, highlight, pow(diff, 5.0));
            gl_FragColor = vec4(shinyGold, 1.0); return;
        }
        gl_FragColor = vec4(blob_color, 1.0);
    }
  `;

  // ===== Blob =====
  class Blob {
    constructor(n=14, color=new THREE.Vector3(1,0,0), pos=new THREE.Vector2(INTERNAL_W/2, INTERNAL_H/2)){
      this.num_circles = n;
      this.color = color;

      const goldBase = new THREE.Vector3(1.0,0.84,0.0);
      if(color.equals(new THREE.Vector3(1,0,0))){
        this.pupil_color = new THREE.Vector3(0,0,1);
      } else if(color.equals(new THREE.Vector3(0,0,1))){
        this.pupil_color = new THREE.Vector3(1,0,0);
      } else if(color.equals(new THREE.Vector3(0.6,0,0.8))){
        this.pupil_color = new THREE.Vector3(0,1,0.6);
      } else if(color.distanceTo(goldBase) < 0.01){
        this.pupil_color = new THREE.Vector3(1.0,0.9,0.3);
      } else {
        this.pupil_color = new THREE.Vector3(1-color.x,1-color.y,1-color.z);
      }

      this.centers = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.radii   = new Float32Array(32);
      this.base_r  = new Float32Array(32);
      this.phase   = new Float32Array(32);
      this.speed   = new Float32Array(32);
      this.targets = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.timer   = new Float32Array(32);

      for(let i=0;i<n;i++){
        this.base_r[i] = rand(10,30);
        this.radii[i]  = this.base_r[i];
        this.phase[i]  = rand(0,TAU);
        this.speed[i]  = rand(0.8,1.5);
        this.targets[i] = new THREE.Vector2(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
        this.timer[i] = rand(1,4);
      }
      this.base_avg_r = Array.from(this.base_r.slice(0,n)).reduce((a,b)=>a+b,0)/n;

      this.eye_pos = pos.clone();
      this.eye_target = this.eye_pos.clone();
      this.eye_timer = rand(0.5, 1.0);
      this.pupil_pos = pos.clone();
      this.pupil_target = pos.clone();
      this.pupil_timer = rand(1,3);

      this.eye_range = 30;
      this.eye_scale = 1.2;
      this.move_speed = 100;
      this.blob_target = pos.clone();
      this.blob_timer  = rand(3, 7);
    }

    // ... update(), uniforms() は後半に続く ...
  }

  // ===== BlobRenderer =====
  class BlobRenderer {
    constructor(){
      this.material = new THREE.RawShaderMaterial({
        vertexShader: VERT,
        fragmentShader: FRAG,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        uniforms: {
          centers:{ value:Array.from({length:32},()=>new THREE.Vector2(0,0)) },
          radii:{ value:Array.from({length:32},()=>0.0) },
          num_circles:{ value:0 },
          blob_color:{ value:new THREE.Vector3(1,0,0) },
          eye_center:{ value:new THREE.Vector2(0,0) },
          eye_radius:{ value:0.0 },
          eye_color:{ value:new THREE.Vector3(1,1,1) },
          pupil_center:{ value:new THREE.Vector2(0,0) },
          pupil_radius:{ value:0.0 },
          pupil_color:{ value:new THREE.Vector3(0,0,0) },
          resolution:{ value:new THREE.Vector2(INTERNAL_W,INTERNAL_H) }
        }
      });
      this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), this.material);
    }
    updateFromBlob(blob){
      const u=blob.uniforms();
      this.material.uniforms.num_circles.value=u.num_circles;
      const centers=this.material.uniforms.centers.value;
      const radii=this.material.uniforms.radii.value;
      for(let i=0;i<32;i++){
        if(i<u.num_circles){ centers[i].copy(u.centers[i]); radii[i]=u.radii[i]; }
        else { centers[i].set(0,0); radii[i]=0.0; }
      }
      this.material.uniforms.blob_color.value.copy(u.blob_color);
      this.material.uniforms.eye_center.value.copy(u.eye_center);
      this.material.uniforms.eye_radius.value=u.eye_radius;
      this.material.uniforms.eye_color.value.copy(u.eye_color);
      this.material.uniforms.pupil_center.value.copy(u.pupil_center);
      this.material.uniforms.pupil_radius.value=u.pupil_radius;
      this.material.uniforms.pupil_color.value.copy(u.pupil_color);
      this.material.uniforms.resolution.value.set(INTERNAL_W,INTERNAL_H);
    }
  }
