<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Metaball (Metallic Gold)</title>
  <style>
    html,body { margin:0; height:100%; background:#111; }
    #app { position:fixed; inset:0; display:grid; place-items:center; }
    #randomBtn {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      background: linear-gradient(90deg, #fff, #000);
      border: 3px solid #b57edc;
      color: #fff;
      cursor: pointer;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <button id="randomBtn">Random Colors</button>

  <script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.4/dist/tweakpane.min.js";

  const INTERNAL_W = 1200, INTERNAL_H = 1200;
  const TAU = Math.PI * 2;
  const rand = (a,b)=> a + Math.random()*(b-a);

  // ==== Shaders ====
  const VERT = `
    precision highp float;
    attribute vec3 position;
    varying vec2 vUv;
    void main() {
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `;
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 centers[32];
    uniform float radii[32];
    uniform int num_circles;
    uniform vec3 blob_color;

    uniform vec2 eye_center;
    uniform float eye_radius;
    uniform vec2 pupil_center;
    uniform float pupil_radius;
    uniform vec3 eye_color;
    uniform vec3 pupil_color;

    uniform vec2 resolution;
    uniform bool is_gold;
    void main(){
        vec2 uv = vUv * resolution;
        float field = 0.0;
        for(int i=0;i<32;i++){
            if(i >= num_circles) break;
            vec2 d = uv - centers[i];
            float d2 = dot(d,d) + 1.0;
            float r = radii[i];
            field += (r*r) / d2;
        }
        if(field <= 0.8){ discard; }

        // pupil
        if(length(uv - pupil_center) < pupil_radius){
            if(is_gold){
                vec2 lightDir = normalize(vec2(-0.6, 0.8));
                vec2 n = normalize(uv - pupil_center);
                float shade = 0.5 + 0.5 * dot(n, lightDir);
                vec3 gold_dark = vec3(0.8, 0.6, 0.1);
                vec3 gold_base = vec3(1.0, 0.9, 0.3);
                vec3 col = mix(gold_dark, gold_base, shade);
                float spec = pow(max(dot(n, lightDir), 0.0), 20.0);
                col += spec * 0.8;
                gl_FragColor = vec4(col, 1.0);
            } else {
                gl_FragColor = vec4(pupil_color, 1.0);
            }
            return;
        }

        // eye white
        if(length(uv - eye_center) < eye_radius){
            gl_FragColor = vec4(eye_color, 1.0);
            return;
        }

        // blob body
        if(is_gold){
            vec2 lightDir = normalize(vec2(-0.6, 0.8));
            vec2 n = normalize(uv - eye_center);
            float shade = 0.5 + 0.5 * dot(n, lightDir);
            vec3 gold_dark = vec3(0.8, 0.6, 0.1);
            vec3 gold_base = vec3(1.0, 0.9, 0.3);
            vec3 col = mix(gold_dark, gold_base, shade);
            float spec = pow(max(dot(n, lightDir), 0.0), 20.0);
            col += spec * 0.6;
            gl_FragColor = vec4(col, 1.0);
        } else {
            gl_FragColor = vec4(blob_color, 1.0);
        }
    }
  `;
    // ==== Blob ====
  class Blob {
    constructor(n=14, color=new THREE.Vector3(1,0,0), pos=new THREE.Vector2(INTERNAL_W/2, INTERNAL_H/2), gold=false){
      this.num_circles = n;
      this.color = color;
      this.is_gold = gold;

      this.pupil_color = new THREE.Vector3(1-color.x,1-color.y,1-color.z);
      if(gold){
        this.pupil_color = new THREE.Vector3(1.0,0.9,0.3);
      }

      this.centers = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.radii   = new Float32Array(32);
      this.base_r  = new Float32Array(32);
      this.phase   = new Float32Array(32);
      this.speed   = new Float32Array(32);
      this.targets = Array.from({length:32}, ()=> new THREE.Vector2(pos.x,pos.y));
      this.timer   = new Float32Array(32);

      for(let i=0;i<n;i++){
        this.base_r[i] = rand(10,30);
        this.radii[i]  = this.base_r[i];
        this.phase[i]  = rand(0,TAU);
        this.speed[i]  = rand(0.8,1.5);
        this.targets[i] = new THREE.Vector2(rand(0,INTERNAL_W), rand(0,INTERNAL_H));
        this.timer[i] = rand(1,4);
      }
      this.base_avg_r = Array.from(this.base_r.slice(0,n)).reduce((a,b)=>a+b,0)/n;

      this.eye_pos = pos.clone();
      this.eye_target = this.eye_pos.clone();
      this.eye_timer = rand(0.5, 1.0);
      this.pupil_pos = pos.clone();
      this.pupil_target = pos.clone();
      this.pupil_timer = rand(1,3);

      this.eye_range = 30;
      this.eye_scale = 1.2;
      this.move_speed = 100;
      this.blob_target = pos.clone();
      this.blob_timer  = rand(3, 7);
    }
    // (このあと Blob クラスの update(), uniforms(), Renderer, Setup, randomColor(), loop など続く)

    // ==== Loop ====
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.05, (now-last)/1000);
      last = now;

      for(const b of blobs){
        b.eye_range = params.eye_range;
        b.max_interval = params.interval;
        b.eye_scale = params.eye_scale;
        b.move_speed = params.move_speed;
        b.update(dt);
      }
      for(let i=0;i<blobs.length;i++){
        for(let j=i+1;j<blobs.length;j++){
          applyForces(blobs[i],blobs[j],dt,params.attract,params.repel);
        }
      }
      for(let i=0;i<blobs.length;i++) renderers[i].updateFromBlob(blobs[i]);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
